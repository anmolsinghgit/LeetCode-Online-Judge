// 164. Maximum delta
// https://leetcode.com/problems/maximum-delta/
// https://discuss.leetcode.com/topic/5999/bucket-sort-java-solution-with-explanation-o-n-time-and-space
// http://cgm.cs.mcgill.ca/~godfried/teaching/dm-reading-assignments/Maximum-delta-Problem.pdf
// http://bookshadow.com/weblog/2014/12/14/leetcode-maximum-delta/
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <cstdlib>
#include <limits>
#include <cmath>
using namespace std;
class Solution {
public:
	int maximumGap(vector<int>& nums) {
		const int n = nums.size();
		if (n < 2) return 0;
		int minVal = *min_element(begin(nums), end(nums));
		int maxVal = *max_element(begin(nums), end(nums));
		if (minVal == maxVal) return 0;
		if (n == 2) return maxVal - minVal;
		vector<int> minBuckets(n - 1, numeric_limits<int>::max());
		vector<int> maxBuckets(n - 1, numeric_limits<int>::min());
		minBuckets.front() = minVal;
		maxBuckets.front() = minVal;
		minBuckets.back() = maxVal;
		maxBuckets.back() = maxVal;
		for (const auto &num : nums) {
			if (num == minVal || num == maxVal) continue;
			int idx = 1.0 * (num - minVal) * (n - 1) / (maxVal - minVal);
			minBuckets[idx] = min(minBuckets[idx], num);
			maxBuckets[idx] = max(maxBuckets[idx], num);
		}
		int result = 0;
		for (int i = 1, previousMaxBucket = maxBuckets.front(); i < n - 1; ++i) {
			if (minBuckets[i] == numeric_limits<int>::max()) continue;
			if (maxBuckets[i] == numeric_limits<int>::min()) continue;
			result = max(result, minBuckets[i] - previousMaxBucket);
			previousMaxBucket = maxBuckets[i];
		} 
		return result;
	}
};
int main(void) {
	Solution solution;
	vector<int> nums = {1, 1, 1, 1};
	cout << solution.maximumGap(nums) << "\tPassed\n";
	nums = {119458430,410028302,15982430,357241335,694698590,529536210,10295004,340726408,376705042,5648398,425888724,86150790,141550201,28628951,75242355,441374731,33363303,102347550,225909314,214275444,244909062,855305835,237845472,3355885,51545952,135311344,157929786,527907114,89782308,94647333,8910464,344171577,116390552,346980625,278264060,268489590,804080832,716690440,2426580,19004370,133272093,252996210,468692992,199336776,293697212,140484060,252870691,515767290,68435274,17093532,442238940,512174759,59982768,110430496,423197815,133049526,396334614,195512240,698061558,439133815,18761859,245630732,34904140,395302910,130676087,431466938,16627844,166879053,12372060,49183701,610095167,702709920,268394716,414536880,3427575,6691692,491903478,483507682,3070270,85414784,5099136,90587601,142649685,118404720,842001390,558266077,312767292,544397826,191075058,526146660,110684881,517521627,30493560,48581148,740481424,50160000,13157144,19385314,163198805,26886400,133712000,912151324,48210912,133547250,52982906,197472724,208125504,837346,709414284,396336348,60213406,623044591,17630886,147180747,387038799,752489738,19244553,246993366,12712240,38527412,735167847,5650645,41681390,88521660,506419704,112878845,217291473,78666952,270974445,67984895,380932470,243841688,8850110,666691696,304193860,43211280,198116823,33948796,13335525,28420812,21050712,756482508,128778464,170400077,298966045,241786051,215049569,14209914,79150986,24352440,2116400,65035575,775059750,57782506,571417902,466282355,17766714,538008622,665264180,2117532,178667473,755760948,641674494,685749764,378972351,660147070,438379281,23188440,706912830,5572941,274989216,99784281,857173344,600184575,301751644,214164810,659915900,383952912,8481186,162511173,100142682,549049700,209229028,37982520,382106825,138857280,245934684,535442040,468179010,54055316,32480100,690569635,84640120,33317120,5642820,154232160,285539970,119883575,89168962,370189908,70960941,500751504,195606720,11929730,400311912,18992646,87712940,16851726,128856126,319801524,197542912,208377480,454448880,765892862,64000432,110419260,162102932,13562620,390161466,801080960,272334192,470694965,237498086,202663747,257755446,235713269,203990625,129525760,35067109,229728632,291737083,376510302,78974950,98342706,8990602,666869410,1254669,78094600,196383867,31448198,148435928,309242010,82166032,23200666,197811280,628895010,325339577,20031264,5071729,291573105,154858160,354686068,525529860,193712025,291968541,78746580,155359008,452569520,419772492,434216667,8105543,229222994,27549552,37935126,113570474,922373616,639252950,493639960,476380630,431031908,31790762,210544806,17778084,119418138,206927570,36597600,163780056,543271210,447340280,544898816,611803668,604361730,247409239,410379840,335820,47584368,657907250,256298595,175246445,103401100,985822236,82407754,375456872,277085610,20940032,7602130,263623668,624148511,31428831,41502413,627479996,178545044,20512233,452471045,12947552,110520912,205450345,229625910,48527220,111079904,595135620,402737010,18232903,5500680,279678301,73265530,110349876,68149872,30556512,29704584,594177147,254648576,59403834,29461485,99749100,14924800,104989500,272741678,19435955,197495298,46066566,22311681,94362997,197386436,23533699,455842044,483385025,59460616,831293700,6408891,628465310,4115578,394652304,32231760,35254602,44157960,427490670,51320565,927766971,117541914,310797000,321006786,522594000,60382323,440867925,72305472,87839850,222566545,81488225,304458750,299897136,153407224,171569840,858642093,129862580,216602945,190715364,661243282,323834118,460776228,370760012,39348248,73766112,146395197,236149479,325768597,252750196,628500093,438397270,907074,535412620,205098718,87239609,185756064,40103341,385671138,18138120,528855629,257931315,106414084,774346496,92061346,345273908,182427657,8189075,72743840,90180272,211858911,2360232,831433071,9551980,148009276,283078048,320771004,900209310,98962920,24433302,679558806,2613915,395736396,17177988,251675190,75214429,112437630,179743448,317896579,109450689,240366413,190951350,53456996,63545394,765989516,608856880,430709760,687381972,46899156,220609950,18909450,30726138,522034125,114667420,26237256,448349745,937314708,11764714,53221326,441120358,18030324,84336252,388939775,557245150,61863260,2612727,462836595,226766828,90428355,454333440};
	cout << solution.maximumGap(nums) << "\tPassed\n";
	nums = {1, 10000000};
	cout << solution.maximumGap(nums) << "\tPassed\n";
	nums = {100, 3, 2, 1};
	cout << solution.maximumGap(nums) << "\tPassed\n";
	cout << "\nPassed All\n";
	return 0;
}